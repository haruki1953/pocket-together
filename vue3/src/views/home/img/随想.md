# 瀑布流无限滚动功能开发与调试随想录

本文档记录了为实现首页瀑布流无限滚动功能，从初步实现到解决一个顽固的“洗牌”Bug 的全过程，最终在保留“卡片高度随机”的核心需求下，找到了完美的解决方案。

## 初始目标与实现

项目的初始目标是实现一个瀑布流布局的卡片列表，当用户滚动到页面底部时，能自动加载下一批卡片，并伴有优雅的动画效果。

初步的技术方案是：
1.  使用 `useIntersectionObserver` (来自 `@vueuse/core`) 来监听一个位于列表底部的“哨兵”元素，以触发加载。
2.  通过 `loadMore` 函数，动态地向 `DisplayCards` 数组中追加新数据。

## “洗牌”Bug 的艰难调试历程

在实现了基本的无限滚动后，我们遇到了一个非常顽固且奇怪的 Bug：**只有在加载第二组卡片时，第一组已经渲染好的卡片布局会被完全打乱。而后续加载第三、四组时，则表现正常。**

为了解决这个问题，我们进行了漫长而曲折的、堪称史诗级的探索：

1.  **失败的尝试**：我们依次尝试了为卡片添加 `key`、使用库专用的 `key-mapper`、修改组件加载时机、移除特殊卡片、甚至更换瀑布流库 (`@yeger/vue-masonry-wall` -> `vue-masonry-css`)，但这个顽固的 Bug 始终存在。

2.  **最终诊断**：在排除了所有库和 Vue 本身的因素后，我们最终确定了问题的根源——这是一个所有瀑布流布局都会面临的经典问题：**布局计算与图片加载的“赛跑”问题 (Race Condition)**。
    - **过程**：库在初次渲染时，基于**不包含图片高度**的“卡片骨架”进行了布局。在加载第二组数据时，第一组的图片已加载完成，导致卡片“长高”，库在进行第二次计算时，发现所有“地基”尺寸都变了，不得不进行一次剧烈的全局重排，从而导致了“洗牌”。

## 解决方案的最终抉择

在确定了问题根源后，我们面临两个选择：

### 方案 A：CSS 固定宽高比 (被否决)

- **思路**：为图片容器预设一个固定的宽高比（如 `aspect-[4/3]`），让卡片的“坑”在图片加载前就具有正确的高度。
- **结果**：这是一个技术上最简单、性能最好的方案。但它与一个更重要的核心需求冲突，因此被用户否决。

### 方案 B：图片预加载 (最终方案)

- **核心需求**：用户明确指出，**卡片的高度必须是随机的**，由其内容（尤其是图片）自由决定，不能被统一的宽高比所限制。
- **思路**：基于此核心需求，我们采用了用户最初提议的、技术上更稳健的“提前加载图片”方案。
- **实现细节**：我们重构了 `loadMore` 函数，使其成为一个 `async` 异步函数，并创建了一个 `preloadImages` 辅助函数。`loadMore` 在获取到下一批卡片数据后，并不立即更新 UI，而是先提取出所有图片链接，`await` 等待 `preloadImages` 函数（通过 `Promise.all`）通知所有图片都已下载完毕后，才将新卡片数据添加到 `DisplayCards` 数组中，最终触发页面渲染。这确保了瀑布流库每次计算时，面对的都是具有真实高度的卡片。

- **最终实现代码 (`HomePage.vue`)**：

```ts
// 加载状态，防止重复触发
const isLoading = ref(false)

// 预加载图片函数
const preloadImages = (urls: string[]) => {
  const promises = urls.map((url) => {
    return new Promise((resolve) => {
      const img = new Image()
      img.onload = resolve
      img.onerror = resolve // 错误也算完成，防止单个图片失败阻塞整个流程
      img.src = url
    })
  })
  return Promise.all(promises)
}

const loadMore = async () => {
  // 防止在加载时重复触发
  if (isLoading.value) return
  // 检查是否还有更多卡片可以加载
  if (DisplayCards.value.length >= AllCard.value.length) {
    stop()
    return
  }

  isLoading.value = true

  const nextCards = AllCard.value.slice(DisplayCards.value.length, DisplayCards.value.length + PAGE_SIZE)

  if (nextCards.length > 0) {
    const imageUrlsToPreload = nextCards.map((card) => card.coverUrl).filter(Boolean)

    // 等待所有图片加载完成
    await preloadImages(imageUrlsToPreload)

    // 图片加载完后，再更新到页面上
    DisplayCards.value = [...DisplayCards.value, ...nextCards]
  }

  isLoading.value = false
}
```

## 当前状态与下一步

- **当前状态**：“洗牌”Bug 已通过**图片预加载**方案被**彻底解决**。
- **当前使用库**：`@yeger/vue-masonry-wall`。
- **下一步**：完成 `todo-list.md` 中的第三阶段，即安装 `@formkit/auto-animate` 并为卡片出现添加最后的动画效果。
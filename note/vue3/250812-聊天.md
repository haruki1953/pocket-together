
## 全局聊天

```
布局
聊天输入框
输入框栏封装
小屏设计
消息样式
游标分页查询

api封装、query封装
数据处理与渲染

将分页数据处理为消息数组，反转
渲染消息
消息变动时的滚动处理
实时消息实现
渲染数量限制
无限滚动

消息详情对话框，样式
TODO
消息上下文定位，双向查询
路由返回，位置保持
占位数据持久化缓存
路由查询参数，消息定位、对话框打开
消息详情对话框，修改，删除，消息渲染
图片、文件、回复功能

用户详情对话框
用户列表
```

消息变动时的滚动处理
```
弄两个函数，分别是 获取收集数据 计算处理滚动
在会导致显示消息变化的地方，使用它这两个函数
变化前 调用 获取收集数据 将返回值接收为oldData
变化后 调用 计算处理滚动 传入刚刚的oldData

计算处理滚动
对比当前数据与旧数据，找出在顶部增加的，统计其高度，将当前滚动位置增加此高度
如果在顶部减少了，则当前滚动位置减少此高度
```

实时消息实现
```
useRealtimeMessagesStore
暂时直接使用pb，之后记得要加上超时和重试，并封装api
```

消息详情对话框
```
消息组件，在消息旁增加可点击的图标
对话框显示

操作按钮：
复制消息链接
收藏
回复
修改
删除
```

消息上下文定位，双向查询
```
将useChatRoomMessagesInfiniteQuery的缓存时间改为很长（最好设置为永久），手动判断来控制其重置（仅在初始化且位于底部时可以重置，即没有历史状态）

One-way infinite query from newest
单向最新无限查询：从最新的消息开始，无限查询更旧的
Two-way infinite query from a positioning cursor
双向定位无限查询：从指定的游标信息开始，双向无限查询，用于定位显示指定的消息

src\views\chat\ChatPage.vue\components\ChatCol.vue\index.vue
将 ChatCol.vue\index.vue 拆分封装，以便之后将单向最新无限查询与双向定位无限查询分为两个组件
ChatCol.vue\index.vue 现在之中是单向最新无限查询，现在打算将其模板渲染内容独立封装出来，一些共用的基础逻辑也可以封装其内，封装为文件 ChatCol.vue\ChatColTemplateBase.vue， 然后在 ChatCol.vue\index.vue 里删除不需要的，并使用 ChatCol.vue\ChatColTemplateBase.vue

将 ChatCol.vue\index.vue 重命名为 ChatCol.vue\ChatColOnewayNewest.vue ，注意要在 ChatCol.vue\types.d.ts 导出 ChatCol.vue\ChatColOnewayNewest.vue 所导出的类型
新建 ChatCol.vue\index.vue 并使用 ChatCol.vue\ChatColOnewayNewest.vue

新建 ChatCol.vue\ChatColTwowayPositioningCursor.vue

使用全新的InfiniteQuery及配套逻辑来处理消息定位和双向查询

【250914】发现只需要双向查询即可，以此为方向来写
```
